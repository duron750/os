--- Makefile
+++ Makefile	1994/01/21 14:39:12
@@ -0,0 +1,14 @@
+CFLAGS = -O2 -fomit-frame-pointer \
+		-include /usr/include/bsd/bsd.h -I/usr/include/bsd
+LDFLAGS = -N -s -v
+LDLIBS = -lbsd
+
+ping:	ping.o
+
+install: ping
+	install ping /sbin
+	install -m644 ping.8 /usr/man/man8
+
+clean:
+	rm -f *.o ping
+
--- ping.c
+++ ping.c	1994/01/21 14:46:34
@@ -69,11 +69,10 @@
 #include <sys/time.h>
 #include <sys/signal.h>
 
-#include <netinet/in_systm.h>
 #include <netinet/in.h>
 #include <netinet/ip.h>
 #include <netinet/ip_icmp.h>
-#include <netinet/ip_var.h>
+#define MAX_IPOPTLEN	4096
 #include <netdb.h>
 #include <unistd.h>
 #include <stdio.h>
@@ -81,6 +80,8 @@
 #include <errno.h>
 #include <string.h>
 
+#define ICMP_MINLEN	32
+
 #define	DEFDATALEN	(64 - 8)	/* default data length */
 #define	MAXIPLEN	60
 #define	MAXICMPLEN	76
@@ -139,9 +140,9 @@
 
 /* timing */
 int timing;			/* flag to do timing */
-double tmin = 100.0*(double)LONG_MAX;		/* minimum round trip time */
-double tmax;			/* maximum round trip time */
-double tsum;			/* sum of all times, for doing average */
+long tmin = LONG_MAX;		/* minimum round trip time */
+long tmax;			/* maximum round trip time */
+u_long tsum;			/* sum of all times, for doing average */
 
 char *pr_addr();
 void catcher(), finish();
@@ -359,6 +360,7 @@
 	(void)setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&hold,
 	    sizeof(hold));
 
+#if 0
 	if (moptions & MULTICAST_NOLOOP) {
 		if (setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP,
 							&loop, 1) == -1) {
@@ -380,6 +382,7 @@
 			exit(94);
 		}
 	}
+#endif
 
 	if (to->sin_family == AF_INET)
 		(void)printf("PING %s (%s): %d data bytes\n", hostname,
@@ -448,7 +451,7 @@
 		alarm((u_int)interval);
 	else {
 		if (nreceived) {
-			waittime = 2 * tmax / 1000000.0;
+			waittime = 2 * tmax / 1000;
 			if (!waittime)
 				waittime = 1;
 		} else
@@ -458,6 +461,23 @@
 	}
 }
 
+#define icmp_type type
+#define icmp_code code
+#define icmp_cksum checksum
+#define icmp_id un.echo.id
+#define icmp_seq un.echo.sequence
+#define icmp_gwaddr un.gateway
+#define ip_hl ihl
+#define ip_v version
+#define ip_tos tos
+#define ip_len tot_len
+#define ip_id id
+#define ip_off frag_off
+#define ip_ttl ttl
+#define ip_p protocol
+#define ip_sum check
+#define ip_src saddr
+#define ip_dst daddr
 /*
  * pinger --
  * 	Compose and transmit an ICMP ECHO REQUEST packet.  The IP packet
@@ -468,11 +488,11 @@
  */
 pinger()
 {
-	register struct icmp *icp;
+	register struct icmphdr *icp;
 	register int cc;
 	int i;
 
-	icp = (struct icmp *)outpack;
+	icp = (struct icmphdr *)outpack;
 	icp->icmp_type = ICMP_ECHO;
 	icp->icmp_code = 0;
 	icp->icmp_cksum = 0;
@@ -515,21 +535,21 @@
 	int cc;
 	struct sockaddr_in *from;
 {
-	register struct icmp *icp;
+	register struct icmphdr *icp;
 	register u_long l;
 	register int i, j;
 	register u_char *cp,*dp;
 	static int old_rrlen;
 	static char old_rr[MAX_IPOPTLEN];
-	struct ip *ip;
+	struct iphdr *ip;
 	struct timeval tv, *tp;
-	double triptime;
+	long triptime;
 	int hlen, dupflag;
 
 	(void)gettimeofday(&tv, (struct timezone *)NULL);
 
 	/* Check the IP header */
-	ip = (struct ip *)buf;
+	ip = (struct iphdr *)buf;
 	hlen = ip->ip_hl << 2;
 	if (cc < hlen + ICMP_MINLEN) {
 		if (options & F_VERBOSE)
@@ -541,19 +561,19 @@
 
 	/* Now the ICMP part */
 	cc -= hlen;
-	icp = (struct icmp *)(buf + hlen);
+	icp = (struct icmphdr *)(buf + hlen);
 	if (icp->icmp_type == ICMP_ECHOREPLY) {
 		if (icp->icmp_id != ident)
 			return;			/* 'Twas not our ECHO */
 		++nreceived;
 		if (timing) {
 #ifndef icmp_data
-			tp = (struct timeval *)&icp->icmp_ip;
+			tp = (struct timeval *)(icp + 1);
 #else
 			tp = (struct timeval *)icp->icmp_data;
 #endif
 			tvsub(&tv, tp);
-			triptime = tv.tv_sec * 1000000.0 + tv.tv_usec;
+			triptime = tv.tv_sec * 10000 + (tv.tv_usec / 100);
 			tsum += triptime;
 			if (triptime < tmin)
 				tmin = triptime;
@@ -581,17 +601,18 @@
 			   icp->icmp_seq);
 			(void)printf(" ttl=%d", ip->ip_ttl);
 			if (timing)
-				(void)printf(" time=%.3f ms", triptime/1000.0);
+				(void)printf(" time=%ld.%ld ms", triptime/10,
+						triptime%10);
 			if (dupflag)
 				(void)printf(" (DUP!)");
 			/* check the data */
-			cp = (u_char*)&icp->icmp_data[8];
+			cp = ((u_char*)(icp + 1) + 8);
 			dp = &outpack[8 + sizeof(struct timeval)];
 			for (i = 8; i < datalen; ++i, ++cp, ++dp) {
 				if (*cp != *dp) {
 	(void)printf("\nwrong data byte #%d should be 0x%x but was 0x%x",
 	    i, *dp, *cp);
-					cp = (u_char*)&icp->icmp_data[0];
+					cp = (u_char*)(icp + 1);
 					for (i = 8; i < datalen; ++i, ++cp) {
 						if ((i % 32) == 8)
 							(void)printf("\n\t");
@@ -610,10 +631,11 @@
 		pr_icmph(icp);
 	}
 
+#if 0
 	/* Display any IP options */
-	cp = (u_char *)buf + sizeof(struct ip);
+	cp = (u_char *)buf + sizeof(struct iphdr);
 
-	for (; hlen > (int)sizeof(struct ip); --hlen, ++cp)
+	for (; hlen > (int)sizeof(struct iphdr); --hlen, ++cp)
 		switch (*cp) {
 		case IPOPT_EOL:
 			hlen = 0;
@@ -685,6 +707,7 @@
 			(void)printf("\nunknown option %x", *cp);
 			break;
 		}
+#endif
 	if (!(options & F_FLOOD)) {
 		(void)putchar('\n');
 		(void)fflush(stdout);
@@ -766,9 +789,11 @@
 			    ntransmitted));
 	(void)putchar('\n');
 	if (nreceived && timing)
-		(void)printf("round-trip min/avg/max = %.3f/%.3f/%.3f ms\n",
-		    tmin / 1000.0, tsum / 1000.0 / (nreceived + nrepeats),
-		    tmax / 1000.0);
+		(void)printf("round-trip min/avg/max = %ld.%ld/%lu.%ld/%ld.%ld ms\n",
+			tmin/10, tmin%10,
+			(tsum / (nreceived + nrepeats))/10,
+			(tsum / (nreceived + nrepeats))%10,
+			tmax/10, tmax%10);
 	exit(0);
 }
 
@@ -793,31 +818,31 @@
  *	Print a descriptive string about an ICMP header.
  */
 pr_icmph(icp)
-	struct icmp *icp;
+	struct icmphdr *icp;
 {
 	switch(icp->icmp_type) {
 	case ICMP_ECHOREPLY:
 		(void)printf("Echo Reply\n");
 		/* XXX ID + Seq + Data */
 		break;
-	case ICMP_UNREACH:
+	case ICMP_DEST_UNREACH:
 		switch(icp->icmp_code) {
-		case ICMP_UNREACH_NET:
+		case ICMP_NET_UNREACH:
 			(void)printf("Destination Net Unreachable\n");
 			break;
-		case ICMP_UNREACH_HOST:
+		case ICMP_HOST_UNREACH:
 			(void)printf("Destination Host Unreachable\n");
 			break;
-		case ICMP_UNREACH_PROTOCOL:
+		case ICMP_PROT_UNREACH:
 			(void)printf("Destination Protocol Unreachable\n");
 			break;
-		case ICMP_UNREACH_PORT:
+		case ICMP_PORT_UNREACH:
 			(void)printf("Destination Port Unreachable\n");
 			break;
-		case ICMP_UNREACH_NEEDFRAG:
+		case ICMP_FRAG_NEEDED:
 			(void)printf("frag needed and DF set\n");
 			break;
-		case ICMP_UNREACH_SRCFAIL:
+		case ICMP_SR_FAILED:
 			(void)printf("Source Route Failed\n");
 			break;
 		default:
@@ -827,40 +852,40 @@
 		}
 		/* Print returned IP header information */
 #ifndef icmp_data
-		pr_retip(&icp->icmp_ip);
+		pr_retip(icp + 1);
 #else
 		pr_retip((struct ip *)icp->icmp_data);
 #endif
 		break;
-	case ICMP_SOURCEQUENCH:
+	case ICMP_SOURCE_QUENCH:
 		(void)printf("Source Quench\n");
 #ifndef icmp_data
-		pr_retip(&icp->icmp_ip);
+		pr_retip(icp + 1);
 #else
 		pr_retip((struct ip *)icp->icmp_data);
 #endif
 		break;
 	case ICMP_REDIRECT:
 		switch(icp->icmp_code) {
-		case ICMP_REDIRECT_NET:
+		case ICMP_REDIR_NET:
 			(void)printf("Redirect Network");
 			break;
-		case ICMP_REDIRECT_HOST:
+		case ICMP_REDIR_HOST:
 			(void)printf("Redirect Host");
 			break;
-		case ICMP_REDIRECT_TOSNET:
+		case ICMP_REDIR_NETTOS:
 			(void)printf("Redirect Type of Service and Network");
 			break;
-		case ICMP_REDIRECT_TOSHOST:
+		case ICMP_REDIR_HOSTTOS:
 			(void)printf("Redirect Type of Service and Host");
 			break;
 		default:
 			(void)printf("Redirect, Bad Code: %d", icp->icmp_code);
 			break;
 		}
-		(void)printf("(New addr: 0x%08lx)\n", icp->icmp_gwaddr.s_addr);
+		(void)printf("(New addr: 0x%08lx)\n", icp->icmp_gwaddr);
 #ifndef icmp_data
-		pr_retip(&icp->icmp_ip);
+		pr_retip(icp + 1);
 #else
 		pr_retip((struct ip *)icp->icmp_data);
 #endif
@@ -869,12 +894,12 @@
 		(void)printf("Echo Request\n");
 		/* XXX ID + Seq + Data */
 		break;
-	case ICMP_TIMXCEED:
+	case ICMP_TIME_EXCEEDED:
 		switch(icp->icmp_code) {
-		case ICMP_TIMXCEED_INTRANS:
+		case ICMP_EXC_TTL:
 			(void)printf("Time to live exceeded\n");
 			break;
-		case ICMP_TIMXCEED_REASS:
+		case ICMP_EXC_FRAGTIME:
 			(void)printf("Frag reassembly time exceeded\n");
 			break;
 		default:
@@ -883,33 +908,33 @@
 			break;
 		}
 #ifndef icmp_data
-		pr_retip(&icp->icmp_ip);
+		pr_retip(icp + 1);
 #else
 		pr_retip((struct ip *)icp->icmp_data);
 #endif
 		break;
-	case ICMP_PARAMPROB:
+	case ICMP_PARAMETERPROB:
 		(void)printf("Parameter problem: pointer = 0x%02x\n",
-		    icp->icmp_hun.ih_pptr);
+		    icp->un.gateway);
 #ifndef icmp_data
-		pr_retip(&icp->icmp_ip);
+		pr_retip(icp + 1);
 #else
 		pr_retip((struct ip *)icp->icmp_data);
 #endif
 		break;
-	case ICMP_TSTAMP:
+	case ICMP_TIMESTAMP:
 		(void)printf("Timestamp\n");
 		/* XXX ID + Seq + 3 timestamps */
 		break;
-	case ICMP_TSTAMPREPLY:
+	case ICMP_TIMESTAMPREPLY:
 		(void)printf("Timestamp Reply\n");
 		/* XXX ID + Seq + 3 timestamps */
 		break;
-	case ICMP_IREQ:
+	case ICMP_INFO_REQUEST:
 		(void)printf("Information Request\n");
 		/* XXX ID + Seq */
 		break;
-	case ICMP_IREQREPLY:
+	case ICMP_INFO_REPLY:
 		(void)printf("Information Reply\n");
 		/* XXX ID + Seq */
 		break;
@@ -933,7 +958,7 @@
  *	Print an IP header with options.
  */
 pr_iph(ip)
-	struct ip *ip;
+	struct iphdr *ip;
 {
 	int hlen;
 	u_char *cp;
@@ -947,8 +972,8 @@
 	(void)printf("   %1x %04x", ((ip->ip_off) & 0xe000) >> 13,
 	    (ip->ip_off) & 0x1fff);
 	(void)printf("  %02x  %02x %04x", ip->ip_ttl, ip->ip_p, ip->ip_sum);
-	(void)printf(" %s ", inet_ntoa(*(struct in_addr *)&ip->ip_src.s_addr));
-	(void)printf(" %s ", inet_ntoa(*(struct in_addr *)&ip->ip_dst.s_addr));
+	(void)printf(" %s ", inet_ntoa(ip->ip_src));
+	(void)printf(" %s ", inet_ntoa(ip->ip_dst));
 	/* dump and option bytes */
 	while (hlen-- > 20) {
 		(void)printf("%02x", *cp++);
@@ -982,7 +1007,7 @@
  *	Dump some info on a returned (via ICMP) IP packet.
  */
 pr_retip(ip)
-	struct ip *ip;
+	struct iphdr *ip;
 {
 	int hlen;
 	u_char *cp;
